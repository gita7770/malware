import os
import numpy as np
import tensorflow as tf
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, classification_report, accuracy_score, precision_score, recall_score, f1_score
from train import load_data, tf_dataset  # Ensure you have this module available
from vit import ViT  # Ensure you have this module available

""" Hyperparameters """
hp = {
    "image_size": 200,
    "num_channels": 3,
    "patch_size": 25,
    "num_patches": (200**2) // (25**2),
    "flat_patches_shape": ((200**2) // (25**2), 25*25*3),
    "batch_size": 16,
    "lr": 1e-4,
    "num_epochs": 500,
    "num_classes": 5,
    "class_names": ["adware", "addisplay", "benign", "trojan", "riskware"],
    "num_layers": 12,
    "hidden_dim": 768,
    "mlp_dim": 3072,
    "num_heads": 12,
    "dropout_rate": 0.1
}

def fgsm_attack(model, images, labels, epsilon):
    images = tf.cast(images, tf.float32)
    with tf.GradientTape() as tape:
        tape.watch(images)
        predictions = model(images)
        loss = tf.keras.losses.categorical_crossentropy(labels, predictions)
    gradient = tape.gradient(loss, images)
    signed_grad = tf.sign(gradient)
    adversarial_images = images + epsilon * signed_grad
    adversarial_images = tf.clip_by_value(adversarial_images, 0, 1)  # Ensure the images are in [0, 1] range
    return adversarial_images

def pgd_attack(model, images, labels, epsilon, alpha, iterations):
    images = tf.cast(images, tf.float32)
    original_images = images

    for i in range(iterations):
        with tf.GradientTape() as tape:
            tape.watch(images)
            predictions = model(images)
            loss = tf.keras.losses.categorical_crossentropy(labels, predictions)
        gradient = tape.gradient(loss, images)
        signed_grad = tf.sign(gradient)
        images = images + alpha * signed_grad
        perturbations = tf.clip_by_value(images - original_images, -epsilon, epsilon)
        images = tf.clip_by_value(original_images + perturbations, 0, 1)  # Ensure the images are in [0, 1] range

    return images

def plot_pdf_perturbations(perturbations, attack_name, save_path):
    perturbation_magnitudes = [np.linalg.norm(perturbation) for perturbation in perturbations]
    sns.set(style='whitegrid')
    plt.figure(figsize=(10, 6))
    sns.kdeplot(perturbation_magnitudes, shade=True)
    plt.title(f'PDF of Perturbation Magnitudes for {attack_name} Attack')
    plt.xlabel('Perturbation Magnitude')
    plt.ylabel('Density')
    plt.savefig(os.path.join(save_path, f'{attack_name}_perturbation_pdf.png'))
    plt.close()

if __name__ == "__main__":
    """ Seeding """
    np.random.seed(42)
    tf.random.set_seed(42)

    """ Paths """
    dataset_path = "/content/malware/3okmalika"
    model_path = "/content/drive/MyDrive/model7.h5"

    """ Dataset """
    train_x, valid_x, test_x = load_data(dataset_path)
    test_ds = tf_dataset(test_x, batch=hp["batch_size"])

    """ Model """
    model = ViT(hp)
    model.load_weights(model_path)
    model.compile(
        loss=tf.keras.losses.CategoricalCrossentropy(from_logits=False),
        optimizer=tf.keras.optimizers.Adam(hp["lr"]),
        metrics=["acc"]
    )

    # Parameters for attacks
    fgsm_epsilon = 0.5
    pgd_epsilon = 0.01
    pgd_alpha = 0.005
    pgd_iterations = 40

    fgsm_perturbations = []
    pgd_perturbations = []

    for images, labels in test_ds:
        adv_images_fgsm = fgsm_attack(model, images, labels, fgsm_epsilon)
        fgsm_perturbation = adv_images_fgsm - images
        fgsm_perturbations.extend(fgsm_perturbation.numpy().flatten())

        adv_images_pgd = pgd_attack(model, images, labels, pgd_epsilon, pgd_alpha, pgd_iterations)
        pgd_perturbation = adv_images_pgd - images
        pgd_perturbations.extend(pgd_perturbation.numpy().flatten())

    # Plot PDFs of perturbations
    save_path = 'img'
    plot_pdf_perturbations(fgsm_perturbations, 'FGSM', save_path)
    plot_pdf_perturbations(pgd_perturbations, 'PGD', save_path)
