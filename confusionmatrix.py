import os
os.environ["TF_CPP_MIN_LOG_LEVEL"] = "2"
import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
from sklearn.metrics import accuracy_score
from train import load_data, tf_dataset  # Ensure you have this module available
from vit import ViT  # Ensure you have this module available

""" Hyperparameters """
hp = {
    "image_size": 200,
    "num_channels": 3,
    "patch_size": 25,
    "num_patches": (200**2) // (25**2),
    "flat_patches_shape": ((200**2) // (25**2), 1875),
    "batch_size": 16,
    "lr": 1e-4,
    "num_epochs": 500,
    "num_classes": 5,
    "class_names": ["adware", "addisplay", "benign", "trojan", "riskware"],
    "num_layers": 12,
    "hidden_dim": 768,
    "mlp_dim": 3072,
    "num_heads": 12,
    "dropout_rate": 0.1
}

def fgsm_attack(model, images, labels, epsilon):
    images = tf.cast(images, tf.float32)
    with tf.GradientTape() as tape:
        tape.watch(images)
        predictions = model(images)
        loss = tf.keras.losses.categorical_crossentropy(labels, predictions)
    gradient = tape.gradient(loss, images)
    signed_grad = tf.sign(gradient)
    adversarial_images = images + epsilon * signed_grad
    adversarial_images = tf.clip_by_value(adversarial_images, 0, 1)  # Ensure the images are in [0, 1] range
    return adversarial_images

def pgd_attack(model, images, labels, epsilon, alpha, iterations):
    images = tf.cast(images, tf.float32)
    original_images = images

    for i in range(iterations):
        with tf.GradientTape() as tape:
            tape.watch(images)
            predictions = model(images)
            loss = tf.keras.losses.categorical_crossentropy(labels, predictions)
        gradient = tape.gradient(loss, images)
        signed_grad = tf.sign(gradient)
        images = images + alpha * signed_grad
        perturbations = tf.clip_by_value(images - original_images, -epsilon, epsilon)
        images = tf.clip_by_value(original_images + perturbations, 0, 1)  # Ensure the images are in [0, 1] range

    return images

if __name__ == "__main__":
    """ Seeding """
    np.random.seed(42)
    tf.random.set_seed(42)

    """ Paths """
    dataset_path = "/content/3okmalika"
    model_path = os.path.join("files", "/content/drive/MyDrive/model.h5")

    """ Dataset """
    train_x, valid_x, test_x = load_data(dataset_path)
    print(f"Train: {len(train_x)} - Valid: {len(valid_x)} - Test: {len(test_x)}")

    test_ds = tf_dataset(test_x, batch=hp["batch_size"])

    """ Model """
    model = ViT(hp)
    model.load_weights(model_path)
    model.compile(
        loss=tf.keras.losses.CategoricalCrossentropy(from_logits=False),
        optimizer=tf.keras.optimizers.Adam(hp["lr"]),
        metrics=["acc"]
    )

    # Evaluate the model on clean data
    print("Evaluating on clean data...")
    clean_loss, clean_acc = model.evaluate(test_ds)
    print(f"Clean data - Loss: {clean_loss}, Accuracy: {clean_acc}")

    # Generate predictions and true labels for clean data
    y_true_clean = []
    y_pred_clean = []

    for images, labels in test_ds:
        preds = model.predict(images)
        y_true_clean.extend(np.argmax(labels, axis=1))
        y_pred_clean.extend(np.argmax(preds, axis=1))

    # Calculate the confusion matrix for clean data
    cm_clean = confusion_matrix(y_true_clean, y_pred_clean)
    print("Confusion Matrix - Clean Data:")
    print(cm_clean)

    # Plot the confusion matrix for clean data
    plt.figure(figsize=(8, 6))
    disp_clean = ConfusionMatrixDisplay(confusion_matrix=cm_clean, display_labels=hp["class_names"])
    disp_clean.plot(cmap=plt.cm.Blues)
    plt.title("Confusion Matrix - Clean Data")
    plt.savefig("confusion_matrix_clean.png")
    plt.show()

    """ FGSM Attack """
    epsilon_fgsm = 0.1  # Example epsilon value for FGSM attack

    # Generate adversarial images using FGSM attack
    adv_images_fgsm = []
    for images, labels in test_ds:
        adv_images = fgsm_attack(model, images, labels, epsilon_fgsm)
        adv_images_fgsm.append(adv_images)

    # Flatten list of batches into one array
    adv_images_fgsm = tf.concat(adv_images_fgsm, axis=0)

    # Evaluate model on FGSM adversarial images
    y_true_fgsm = []
    y_pred_fgsm = []

    for images, labels in test_ds:
        preds = model.predict(images)
        y_true_fgsm.extend(np.argmax(labels, axis=1))
        y_pred_fgsm.extend(np.argmax(preds, axis=1))

    # Calculate the confusion matrix for FGSM attack
    cm_fgsm = confusion_matrix(y_true_fgsm, y_pred_fgsm)
    print("Confusion Matrix - FGSM Attack:")
    print(cm_fgsm)

    # Plot the confusion matrix for FGSM attack
    plt.figure(figsize=(8, 6))
    disp_fgsm = ConfusionMatrixDisplay(confusion_matrix=cm_fgsm, display_labels=hp["class_names"])
    disp_fgsm.plot(cmap=plt.cm.Blues)
    plt.title("Confusion Matrix - FGSM Attack")
    plt.savefig("confusion_matrix_fgsm.png")
    plt.show()

    """ PGD Attack """
    epsilon_pgd = 0.3  # Example epsilon value for PGD attack
    alpha_pgd = 0.05
    iterations_pgd = 40

    # Generate adversarial images using PGD attack
    adv_images_pgd = []
    for images, labels in test_ds:
        adv_images = pgd_attack(model, images, labels, epsilon_pgd, alpha_pgd, iterations_pgd)
        adv_images_pgd.append(adv_images)

    # Flatten list of batches into one array
    adv_images_pgd = tf.concat(adv_images_pgd, axis=0)

    # Evaluate model on PGD adversarial images
    y_true_pgd = []
    y_pred_pgd = []

    for images, labels in test_ds:
        preds = model.predict(images)
        y_true_pgd.extend(np.argmax(labels, axis=1))
        y_pred_pgd.extend(np.argmax(preds, axis=1))

    # Calculate the confusion matrix for PGD attack
    cm_pgd = confusion_matrix(y_true_pgd, y_pred_pgd)
    print("Confusion Matrix - PGD Attack:")
    print(cm_pgd)

    # Plot the confusion matrix for PGD attack
    plt.figure(figsize=(8, 6))
    disp_pgd = ConfusionMatrixDisplay(confusion_matrix=cm_pgd, display_labels=hp["class_names"])
    disp_pgd.plot(cmap=plt.cm.Blues)
    plt.title("Confusion Matrix - PGD Attack")
    plt.savefig("confusion_matrix_pgd.png")
    plt.show()
