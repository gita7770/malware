import os
os.environ["TF_CPP_MIN_LOG_LEVEL"] = "2"
import numpy as np
import tensorflow as tf
import matplotlib
matplotlib.use('Agg')  # Use Agg backend which doesn't require a display
import matplotlib.pyplot as plt
from PIL import Image
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay, roc_curve, auc
from sklearn.metrics import accuracy_score, classification_report
from train import load_data, tf_dataset  # Ensure you have this module available
from vit import ViT  # Ensure you have this module available

""" Hyperparameters """
hp = {}
hp["image_size"] = 200
hp["num_channels"] = 3
hp["patch_size"] = 25
hp["num_patches"] = (hp["image_size"]**2) // (hp["patch_size"]**2)
hp["flat_patches_shape"] = (hp["num_patches"], hp["patch_size"]*hp["patch_size"]*hp["num_channels"])

hp["batch_size"] = 16
hp["lr"] = 1e-4
hp["num_epochs"] = 500
hp["num_classes"] = 5
hp["class_names"] = ["adware", "addisplay", "benign", "trojan", "riskware"]
hp["num_layers"] = 12
hp["hidden_dim"] = 768
hp["mlp_dim"] = 3072
hp["num_heads"] = 12
hp["dropout_rate"] = 0.1

def load_image(image_path, image_size):
    img = Image.open(image_path).convert('RGB')
    img = img.resize((image_size, image_size))
    return np.array(img) / 255.0

def preprocess_image(image, patch_size):
    """ Preprocess image into patches and flatten them. """
    patches = []
    for i in range(0, image.shape[0], patch_size):
        for j in range(0, image.shape[1], patch_size):
            patch = image[i:i+patch_size, j:j+patch_size, :]
            patches.append(patch.flatten())
    return np.array(patches)

def fgsm_attack(model, images, labels, epsilon):
    images = tf.cast(images, tf.float32)
    with tf.GradientTape() as tape:
        tape.watch(images)
        predictions = model(images)
        loss = tf.keras.losses.categorical_crossentropy(labels, predictions)
    gradient = tape.gradient(loss, images)
    signed_grad = tf.sign(gradient)
    adversarial_images = images + epsilon * signed_grad
    adversarial_images = tf.clip_by_value(adversarial_images, 0, 1)  # Ensure the images are in [0, 1] range
    return adversarial_images

def pgd_attack(model, images, labels, epsilon, alpha, iterations):
    images = tf.cast(images, tf.float32)
    original_images = images

    for i in range(iterations):
        with tf.GradientTape() as tape:
            tape.watch(images)
            predictions = model(images)
            loss = tf.keras.losses.categorical_crossentropy(labels, predictions)
        gradient = tape.gradient(loss, images)
        signed_grad = tf.sign(gradient)
        images = images + alpha * signed_grad
        perturbations = tf.clip_by_value(images - original_images, -epsilon, epsilon)
        images = tf.clip_by_value(original_images + perturbations, 0, 1)  # Ensure the images are in [0, 1] range

    return images

def plot_images(original, perturbed, adversarial, index, save_path):
    fig, axs = plt.subplots(1, 3, figsize=(15, 5))

    axs[0].imshow(original)
    axs[0].set_title('Original Image')
    axs[0].axis('off')

    axs[1].imshow(perturbed)
    axs[1].set_title('Perturbed Image')
    axs[1].axis('off')

    axs[2].imshow(adversarial)
    axs[2].set_title('Adversarial Image')
    axs[2].axis('off')

    plt.tight_layout(pad=3.0)
    os.makedirs(save_path, exist_ok=True)
    plt.savefig(os.path.join(save_path, f'image_{index}.png'))
    plt.close()

if __name__ == "__main__":
    """ Seeding """
    np.random.seed(42)
    tf.random.set_seed(42)

    """ Paths """
    dataset_path = "/content/3okmalika"
    model_path = "/content/drive/MyDrive/model.h5"
    single_image_path = "/content/3okmalika/single_image.png"  # Replace with your actual image path

    """ Model """
    model = ViT(hp)
    model.load_weights(model_path)
    model.compile(
        loss=tf.keras.losses.CategoricalCrossentropy(from_logits=False),
        optimizer=tf.keras.optimizers.Adam(hp["lr"]),
        metrics=["acc"]
    )

    """ Load Single Image """
    original_image = load_image(single_image_path, hp["image_size"])
    original_image_batch = np.expand_dims(original_image, axis=0)
    dummy_label = np.zeros((1, hp["num_classes"]))
    dummy_label[0, 2] = 1  # Adjust the label index according to your class (example: "benign")

    """ Preprocess Image """
    preprocessed_image = preprocess_image(original_image, hp["patch_size"])
    preprocessed_image_batch = np.expand_dims(preprocessed_image, axis=0)

    """ Generate Adversarial Images """
    epsilon = 0.05
    alpha = 0.01
    iterations = 10

    adv_image_fgsm = fgsm_attack(model, preprocessed_image_batch, dummy_label, epsilon)[0].numpy()
    adv_image_pgd = pgd_attack(model, preprocessed_image_batch, dummy_label, epsilon, alpha, iterations)[0].numpy()

    """ Plot and Save Images """
    save_path = 'adversarial_images'
    plot_images(original_image, original_image, adv_image_fgsm.reshape(hp["image_size"], hp["image_size"], hp["num_channels"]), 0, save_path)
    plot_images(original_image, original_image, adv_image_pgd.reshape(hp["image_size"], hp["image_size"], hp["num_channels"]), 1, save_path)
