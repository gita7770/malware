import numpy as np
import matplotlib.pyplot as plt
import os
import tensorflow as tf
from PIL import Image
from tensorflow.keras.utils import get_custom_objects

# Assuming ClassToken is defined in your code
# Define or import your custom layer here
class ClassToken(tf.keras.layers.Layer):
    # Your custom layer implementation
    pass

custom_objects = {'ClassToken': ClassToken}

# Load the model with custom_objects
model = tf.keras.models.load_model(model_path, custom_objects=custom_objects, compile=False)


# Function to load an image from a file path
def load_image(image_path):
    with Image.open(image_path) as img:
        img = img.convert('RGB')  # Ensure the image is in RGB format
        return np.array(img) / 255.0  # Normalize to [0, 1]

# FGSM Attack
def fgsm_attack(model, images, labels, epsilon):
    images = tf.cast(images, tf.float32)
    labels = tf.cast(labels, tf.float32)
    with tf.GradientTape() as tape:
        tape.watch(images)
        predictions = model(images)
        loss = tf.keras.losses.CategoricalCrossentropy(from_logits=False)(labels, predictions)
    gradient = tape.gradient(loss, images)
    signed_grad = tf.sign(gradient)
    adversarial_images = images + epsilon * signed_grad
    adversarial_images = tf.clip_by_value(adversarial_images, 0, 1)
    return adversarial_images

# PGD Attack
def pgd_attack(model, images, labels, epsilon, alpha, num_iter):
    images = tf.cast(images, tf.float32)
    original_images = images

    for _ in range(num_iter):
        with tf.GradientTape() as tape:
            tape.watch(images)
            predictions = model(images)
            loss = tf.keras.losses.CategoricalCrossentropy(from_logits=False)(labels, predictions)
        gradient = tape.gradient(loss, images)
        signed_grad = tf.sign(gradient)
        images = images + alpha * signed_grad
        perturbations = tf.clip_by_value(images - original_images, -epsilon, epsilon)
        images = tf.clip_by_value(original_images + perturbations, 0, 1)
        
    return images

# Function to plot and save images
def plot_images(original, perturbed, adversarial, index, save_path):
    img_height, img_width, _ = original.shape
    figsize = (img_width / 100, img_height / 100)  # Adjust the divisor to scale figure size appropriately

    fig, axs = plt.subplots(1, 3, figsize=figsize)

    axs[0].imshow(original)
    axs[0].set_title('Original Image')
    axs[0].axis('off')  # Hide axes

    axs[1].imshow(perturbed)
    axs[1].set_title('Perturbed Image')
    axs[1].axis('off')  # Hide axes

    axs[2].imshow(adversarial)
    axs[2].set_title('Adversarial Image')
    axs[2].axis('off')  # Hide axes

    plt.tight_layout()

    if not os.path.exists(save_path):
        os.makedirs(save_path)

    file_name = os.path.join(save_path, f'image_{index}.png')
    plt.savefig(file_name, bbox_inches='tight', pad_inches=0)
    plt.close()

# Main execution
if __name__ == "__main__":
    # Load the pre-trained model
    model_path = '/content/malware/files/model.h5'  # Replace with your actual model path
    model = tf.keras.models.load_model(model_path, compile=False)

    # Path to the original image
    original_image_path = '/content/malware/train/addisplay/addisplay0047.png'  # Replace with your actual image path

    # Load the original image
    original_image = load_image(original_image_path)

    # Convert image to batch format and create dummy labels
    original_image_batch = np.expand_dims(original_image, axis=0)
    dummy_labels = np.array([[1, 0, 0, 0, 0]])  # Dummy label for the image, adjust as needed

    # Generate adversarial images using FGSM and PGD attacks
    epsilon = 0.05  # Perturbation magnitude
    alpha = 0.01  # Step size for PGD
    num_iter = 10  # Number of iterations for PGD

    # FGSM Attack
    adv_images_fgsm = fgsm_attack(model, original_image_batch, dummy_labels, epsilon)
    adv_image_fgsm = adv_images_fgsm[0].numpy()

    # PGD Attack
    adv_images_pgd = pgd_attack(model, original_image_batch, dummy_labels, epsilon, alpha, num_iter)
    adv_image_pgd = adv_images_pgd[0].numpy()

    # Define save path
    save_path = 'adversarial_images3'

    # Plot and save images
    plot_images(original_image, original_image, adv_image_fgsm, 0, save_path)
    plot_images(original_image, original_image, adv_image_pgd, 1, save_path)
